import java.util.*;
import javax.swing.*;
import java.awt.*;
import java.awt.geom.*;
import java.awt.image.BufferedImage;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.File;
import javax.imageio.ImageIO;
import java.io.StringReader;
import java.util.logging.Level;
import java.util.logging.Logger;
public class TSP extends javax.swing.JFrame {

    public TSP() {
        initComponents();
        this.setResizable(false);

    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">                          
    private void initComponents() {

        jScrollPane2 = new javax.swing.JScrollPane();
        jTextArea1 = new javax.swing.JTextArea();
        jButton1 = new javax.swing.JButton();
        jScrollPane1 = new javax.swing.JScrollPane();
        jTextArea2 = new javax.swing.JTextArea();
        jScrollPane4 = new javax.swing.JScrollPane();
        jTextArea4 = new javax.swing.JTextArea();
        jPanel1 = new javax.swing.JPanel();
        jScrollPane3 = new javax.swing.JScrollPane();
        jTextPane1 = new javax.swing.JTextPane();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Delivery Simulator");
        setBackground(new java.awt.Color(255, 0, 204));

        jTextArea1.setColumns(20);
        jTextArea1.setRows(5);
        jScrollPane2.setViewportView(jTextArea1);

        jButton1.setBackground(new java.awt.Color(204, 0, 0));
        jButton1.setForeground(new java.awt.Color(0, 0, 0));
        jButton1.setText("Compute");
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        jTextArea2.setEditable(false);
        jTextArea2.setColumns(20);
        jTextArea2.setRows(5);
        jTextArea2.setText("How To Use:\n1.Copy and paste addresses into text field to the left.\n2.Click Run below.\n3.Observe the output below for the optimum order of\naddresses in which to take.");
        jScrollPane1.setViewportView(jTextArea2);

        jTextArea4.setColumns(20);
        jTextArea4.setRows(5);
        jScrollPane4.setViewportView(jTextArea4);

        jPanel1.setBackground(new java.awt.Color(204, 204, 255));
        jPanel1.setForeground(new java.awt.Color(255, 0, 0));
        jPanel1.setLayout(new java.awt.BorderLayout());

        jTextPane1.setText("Made by Harry Murphy \nRobitcs and Intelligent Devices(NUIM)\n19399926");
        jScrollPane3.setViewportView(jTextPane1);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 257, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 362, Short.MAX_VALUE)
                    .addComponent(jScrollPane4, javax.swing.GroupLayout.DEFAULT_SIZE, 362, Short.MAX_VALUE)))
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jButton1, javax.swing.GroupLayout.PREFERRED_SIZE, 91, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(0, 0, Short.MAX_VALUE))
                    .addComponent(jScrollPane3, javax.swing.GroupLayout.DEFAULT_SIZE, 249, Short.MAX_VALUE))
                .addGap(18, 18, 18)
                .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, 441, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jScrollPane4, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addComponent(jScrollPane2))
                .addGap(18, 18, 18)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(0, 0, Short.MAX_VALUE)
                        .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, 338, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(0, 17, Short.MAX_VALUE))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jButton1, javax.swing.GroupLayout.PREFERRED_SIZE, 43, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(jScrollPane3, javax.swing.GroupLayout.PREFERRED_SIZE, 104, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap())
        );

        pack();
    }// </editor-fold>                        

    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {                                         
        if(evt.getSource()==jButton1)//if the run button is pressed
        {
            /////////////////// TAKING IN INPUT/////////////////////////////
            int lines=jTextArea1.getLineCount();//take in lines
            String s1=jTextArea1.getText();//take the text into string
            String array[]=s1.split("\\n");//split by end of line
            profile array2[]=new profile[lines+1];//creating class pos profile
            profile apache=new profile(0,53.3812226,-6.5929933,0,0);//creating apache profile for comparison
            ///////////////////////////////////////////////////////////
            
            /////////////////CREATING PROFILE ARRAY///////////////////
            for(int i=0;i<lines;i++)
            {
                array2[i]=new profile();//filling array with new profile
                array2[i].set_number(i+1);//setting number of houses
                
            }
            //////////////////////////////////////////////////////////
            
            //////////////////////BREAKING UP INPUT////////////////////
            for(int i=0;i<lines;i++)
            {
                String []tempArray=array[i].split(",");//splitting by commas
                String tempMin=tempArray[tempArray.length-3];//isolating the minutes waiting
                String tempNorth=tempArray[tempArray.length-2];//isolating the north coordinates
                String tempWest=tempArray[tempArray.length-1];//isolating the west coordinates
                array2[i].set_minutes(Integer.parseInt(tempMin));//setting them minutes for each profile
                array2[i].set_north(Double.parseDouble(tempNorth));//setting north for each profile
                array2[i].set_west(Double.parseDouble(tempWest));//setting west for each profile
            }
            ///////////////////////////////////////////////////////////

            //////////////////////ADJACENCY MATRIX/////////////////////
            profile distance[][]=new profile[lines][lines];//new 2d profile array for distance
            for(int i=0;i<lines;i++)
            {
                for(int j=0;j<lines;j++)
                {
                    distance[i][j]=new profile();//assigning new profile to each position
                    distance[i][j].set_distance(array2[i].get_gpsDistance(array2[j]));//setting distance of each profile to the next one
                }
            }
            //////////////////////////////////////////////////////////////
            
            ///////////////////////FINDING START POINT/////////////////////////////
            double startArray[]=new double[lines];//new 2d store for distances
            for(int i=0;i<lines;i++)
            {
                startArray[i]=apache.get_gpsDistance(array2[i]);//getting all distances from apache to inputs
            }
            int startPoint=0;//variable for start point
            double min = startArray[0];//compare anchor   
            for (int i = 0; i < lines; i++)
            {  
               if(startArray[i] <min) //find smallest 
               {
                   min =startArray[i];//assign smallest  
                   startPoint=i;//find position 
               }
            } 
            //////////////////////////////////////////////////////////////////////
         
            //////////////////////NEAREST NEIGHBOR ALGORITHM////////////////////////
            
            double smallest;//smallest store
            int minPos=0;//minimum position store
            int pos=startPoint;//startpoint is position with smallest distance from optarray
            String order="";//string for the order for the driver
            String order2="";
            order+=Integer.toString(pos+1)+",";//adding starting pos to order
            boolean bool[]=new boolean[lines];//boolean array to keep strack of visited
            double totDistance=0;//variable to hold total distance traveled 
            for(int count=0;count<lines-1;count++)
            {
                bool[pos]=true;//setting the position to be visited
                smallest=10000;//comparitor 
                for(int i=0;i<lines;i++)
                {
                    if(distance[pos][i].get_distance()<smallest )//check for a new smaller one
                    {
                        if(checkArray(bool,i)==false&&i!=pos)//if it has not been visited and it is not along the diagonal
                        {
                            smallest=distance[pos][i].get_distance();//get the distance and assign it
                            minPos=i;//find the position with the least distance
                        }
                    }
                }
                order+=Integer.toString(minPos+1)+",";//add address to output string
                order2=order;
                totDistance+=smallest;//add distance travelled to total distance
                pos=minPos;//assing the smallest position 
            }
            System.out.println(totDistance);//printing out the distance travelled
            
            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            
            ////////////////////////////////2-OPT ALGORITHM///////////////////////////////////////////////////////////////////
            String optOrder=(TwoOpt(order,array2,lines,apache));//first call on order without 2opt
            String optOrder2=(TwoOpt(optOrder,array2,lines,apache));
            if(get_totDistance(array2,optOrder,apache,lines)<get_totDistance(array2,order,apache,lines))//if the route has actually been improved
            {
                
                while(get_totDistance(array2,optOrder2,apache,lines)!=get_totDistance(array2,optOrder2,apache,lines))//while the distances are not the smae
                {
                    optOrder=(TwoOpt(optOrder,array2,lines,apache));//call 2opt on itself
                    optOrder2=(TwoOpt(optOrder2,array2,lines,apache));//call 2opt on itself
                }
            }
            else
            {
                optOrder2=order;//if not a better route, leave it alone
            }
            jTextArea4.setText(optOrder2);//set new optimized route to jtextarea
            ////////////////////////////////////////////////
            
            Graphics2D gfx=(Graphics2D)jPanel1.getGraphics();//graphics 
            gfx.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);//graphics
            
            
            ////////////////////////////////////////////////////////////////////////////////////////////////////////
            
            ////////////////////////////////////GRAPHICS/////////////////////////////////////////////////////////////
            double max_north=53.41318;//north boundary 
            double min_north=53.28271;//noth boundary 
            double max_west=-6.45509;//west boundary 
            double min_west=-6.71319;//west boundary
            BufferedImage image = null;//creating new image
            int width=441;//max width of jpanel 
            int height=338;//max height of jpanel 
            String array1[]=optOrder2.split(",");//splitting opt order by ","
            profile array3[]=new profile[lines];//create new profile array
            profile array2Copy[]=array2;//new copy of array2
            for(int i=0;i<lines;i++)
            {
                profile position=array2Copy[Integer.parseInt(array1[i])-1];
                array3[i]=position;//filling new profile array
                double westCoord=array3[i].get_west();//getting west cooardinate in array3 at pos i 
                double northCoord=array3[i].get_north();//getting north coordinate in array3 at pos i
                array3[i].set_west(get_scaledWest(westCoord));//assigning new scaled coordinate to profile
                array3[i].set_north(0+(338-get_scaledNorth(northCoord)));//assigning new scaled coordinate to profile
            }
            try
            {
                image=ImageIO.read(new File("/map.png"));//GET RID OF PREVIOUS PATHS BEFORE SUBMITTING
            }catch(IOException e)
            {
                System.out.println("Image not found");
            }
            gfx.drawImage(image,0,0,441,338,Color.RED,null);//draw map image
            
            profile apache2=new profile();//new copy of apache 
            apache2.set_west(get_scaledWest(apache.get_west()));//scaling apache cooardinates to fit on jpanel 
            apache2.set_north(0+(338-get_scaledNorth(apache.get_north())));//scaling apache coordinates to fit on jpanel 
            Shape start=new Rectangle2D.Double(apache2.get_west(),apache2.get_north(),5,5);
            gfx.draw(start);//drawing point for apache
            gfx.fill(start);
            gfx.draw(new Line2D.Double(apache2.get_west(),apache2.get_north(),array3[0].get_west(),array3[0].get_north()));//drawing lines from apache to first point in array
            
            for(int i=0;i<lines;i++)
            {
                gfx.draw(new Ellipse2D.Double(array3[i].get_west(),array3[i].get_north(),5,5));//draw remaining circles
            }
            for(int i=0;i<lines-1;i++)
            {
                gfx.draw(new Line2D.Double(array3[i].get_west(),array3[i].get_north(),array3[i+1].get_west(), array3[i+1].get_north()));//draw line from i to i+1
            }
        }
   
    }                                        

    /**
     * @param args the command line arguments
     */
    public static void main(String args[])
    {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        new TSP().setResizable(false);
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(TSP.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(TSP.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(TSP.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(TSP.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>
        
        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() 
        {
            public void run() 
            {
                new TSP().setVisible(true);//running jframe 
            }
        });
        
          
        }


       
    
    /*
    This function is used to check if the position has already been visited
    */
    
    boolean checkArray(boolean array[],int pos)
    {
        if(array[pos]==true)//if the boolean at pos is true
        {
            return true;//return true
        }
        else//else
        {
            return false;//return false
        }
    }
    /*
    this function is used to get the equivalent west coordinates for the jframe from the orginal coordinates
    */
    double get_scaledWest(double west_co)
    {
           
        double max_west=-6.45509;//max west coordinate
        double min_west=-6.71319;//min west coordinate
        double scaleWest=(441)/(max_west-min_west);//scaling the west coordinate by dividing the height of jpanel by max-min
        west_co=west_co-min_west;
        west_co=west_co*scaleWest;//multiplying by scale west calculated above
        return west_co;//returning new fitted coordinate
    }
    /*
    this function is used to get the equivalent north coordinates for the jframe from the orginal coordinates
    */
    double get_scaledNorth(double north_co)
    {
        double max_north=53.41318;//max north coordinate
        double min_north=53.28271;//min north coordinate
        double scaleNorth=(338)/(max_north-min_north);//scaling north coordinate by dividing the height of the jpanel by max-min
        north_co=north_co-min_north;
        north_co=north_co*scaleNorth;//multiplying the scale north calculated above
        return north_co;//return new fitted coordinate
    }
    /*
    this function is used to get the total distance travelled from a given route 
    */
    double get_totDistance(profile[]array,String order,profile apache,int lines)
    {
        profile array2[]=new profile[lines];
        String tempArray[]=order.split(",");//Splitting order up 
        for(int i=0;i<lines;i++)
        {
            array2[i]=array[Integer.parseInt(tempArray[i])-1];//assigning profile from profile array to new array in order
        }
        double total_distance=0;
        total_distance=total_distance+apache.get_gpsDistance(array2[0]);//getting initial distance from apache to first address
        for(int i=0;i<lines-1;i++)
        {       
            double distance=array2[i].get_gpsDistance(array2[i+1]);//getting distance from one address to the next 
            total_distance=total_distance+distance;//adding distance to variable 

        }
        return total_distance;//returning total distance 
    }
    /*
    this function is my impementation of the 2opt optimization algorithm 
    */
    String TwoOpt(String order,profile array2[],int lines,profile apache)
    {
         String ord[]=order.split(",");//splitting order being passed in 
            profile arrayX[]=new profile[lines+1];
            for(int i=0;i<arrayX.length-1;i++)
            {
                arrayX[i]=array2[Integer.parseInt(ord[i])-1];//fill new array in order 
            }
            
            for(int i=1;i<lines-1;i++)
            {
                for(int j=i+1;j<lines-1;j++)
                {
                        if(arrayX[i].get_gpsDistance(arrayX[j])+arrayX[i+1].get_gpsDistance(arrayX[j+1])<arrayX[i].get_gpsDistance(arrayX[i+1])+arrayX[j].get_gpsDistance(arrayX[j+1]))//checking if the new route is shorter
                        {
                            int left=i+1;//swapping
                            int right=j;//swapping 
                            while (left <= right) 
                            {
                                profile temp = arrayX[left];//swapping 
                                arrayX[left] = arrayX[right];//swapping
                                arrayX[right] = temp;//swapping

                                left++;//increment
                                right--;//decrement
                            }
                        }
                }
            }
            String newOrder="";
            for(int i=0;i<lines;i++)
            {
               newOrder+=Integer.toString(arrayX[i].get_number())+",";//adding new optimized order to string
            }
            newOrder=newOrder.substring(0,newOrder.length()-1);//getting rid of comma at the end 
            return newOrder;//returning new order 
    }

    // Variables declaration - do not modify                     
    private javax.swing.JButton jButton1;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JScrollPane jScrollPane4;
    private javax.swing.JTextArea jTextArea1;
    private javax.swing.JTextArea jTextArea2;
    private javax.swing.JTextArea jTextArea4;
    private javax.swing.JTextPane jTextPane1;
    // End of variables declaration                   
}
/*
This class is used to create a profile for each individual house that is to be delivered to it holds all
information apart from the address as it was unnessecary 
*/
class profile
{
    int number;//what order number 
    double minutes;//how many minutes waiting
    double north;//the north coordinates
    double west;//the west coordinates
    double distance;//distance
    profile()//constructor
    {
        number=0;//set number to 0
        minutes=0;//set minutes to 0
        west=0;//set west to 0
        north=0;//set north to 0
        distance=0;//set distance to 0
    }
    profile(int number,double north,double west,double distance,double minutes)//general constructor 
    {
        this.number=number;//set number to input
        this.minutes=minutes;//set minutes to input
        this.north=north;//set north to input
        this.west=west;//set west to input
        this.distance=distance;//set distance to input
    }
    /*
    Following methods are setter methods for each variable 
    */
    void set_number(int number)
    {
        this.number=number;
    }
    void set_minutes(double minutes)
    {
        this.minutes=minutes;
    }
    void set_west(double west)
    {
        this.west=west;
    }
    void set_north(double north)
    {
        this.north=north;
    }
    void set_distance(double distance)
    {
        this.distance=distance;
    }
    /*
    Folloing methods are getter methods for each variable
    */
    int get_number()
    {
        return this.number;
    }
    double get_minutes()
    {
        return this.minutes;
    }
    double get_west()
    {
        return this.west;
    }
    double get_north()
    {
        return this.north;
    }
    double get_distance()
    {
        return this.distance;
    }
    /*
    this methods prints a particular house details(not used but good to have)
    */
    void print_details()
    {
        System.out.println("===============================");
        System.out.println("Number:"+this.get_number());
        System.out.println("Minutes:"+this.get_minutes());
        System.out.println("North: "+this.get_north());
        System.out.println("West: "+this.get_west());
        System.out.println("===============================");
    }
    /*
    this method is used to get the gps distance between 2 points
    */
    double get_gpsDistance(profile p2)
    {
        double lat1 = Math.toRadians(this.get_west());
        double lon1 = Math.toRadians(this.get_north());
        double lat2 = Math.toRadians(p2.get_west());
        double lon2 = Math.toRadians(p2.get_north());
        double deltaLon = lon2 - lon1;
        double deltaLat = lat2 - lat1;
        double r = 6371;
        double dist=(2 * Math.asin(Math.sqrt(Math.pow(Math.sin(deltaLat / 2), 2)+ Math.cos(lat1) * Math.cos(lat2)* Math.pow(Math.sin(deltaLon / 2),2))))*(r);
        return dist;
    }
    
}






  
